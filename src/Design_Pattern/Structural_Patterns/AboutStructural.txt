
Structural Design Patterns

Structural design patterns show us how to glue different
pieces of a system together in a flexible and extensible
fashion. These patterns help us guarantee that when one of the parts changes, the entire application structure does not need to change.

DESIGN PATTERN NAME	PURPOSE

Adapter

    An adapter convert the interface of a class into another interface clients expect. It lets classes work together that couldn’t otherwise because of incompatible interfaces.

Bridge

    Bridge design pattern is used to decouple a class into two parts – abstraction and it’s implementation – so that both can evolve in future without affecting each other. It increases the loose coupling between class abstraction and it’s implementation.

Composite

    Composite design pattern helps to compose the objects into tree structures to represent whole-part hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.

Decorator

    Decorator design pattern is used to add additional features or behaviors to a particular instance of a class, while not modifying the other instances of same class.

Facade

    Facade design pattern provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.

Flyweight

    Flyweight design pattern enables use sharing of objects to support large numbers of fine-grained objects efficiently. A flyweight is a shared object that can be used in multiple contexts simultaneously. The flyweight acts as an independent object in each context.

Proxy

    In proxy design pattern, a proxy object provide a surrogate or placeholder for another object to control access to it. Proxy is heavily used to implement lazy loading related usecases where we do not want to create full object until it is actually needed.